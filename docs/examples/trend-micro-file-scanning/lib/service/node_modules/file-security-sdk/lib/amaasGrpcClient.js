"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AmaasGrpcClient = void 0;
const fs_1 = require("fs");
const grpc_js_1 = require("@grpc/grpc-js");
const scan_grpc_pb_1 = require("./protos/scan_grpc_pb");
const scanRun_1 = require("./scanRun");
const utils_1 = require("./utils");
const logger_1 = require("./logger");
/**
 * Class AmaasGrpcClient
 */
class AmaasGrpcClient {
    /**
     * AmaasGrpcClient constructor
     * @param amaasHostName - AMaaS host name or region name
     * @param credent - AmaasCredentials object
     * @param timeout - number in seconds to wait before closing the connection
     * @param enableTLS - enabling TLS
     * @param caCert - full path name of CA certificate pem file for self hosted scanner server. null if using Trend scanner services.
     * @param appName - application name
     */
    constructor(amaasHostName, credent, timeout = 300, enableTLS = true, caCert = null, appName = 'V1FS') {
        /**
         * Close scan client
         */
        this.close = () => {
            // Close channel
            this.scanClient.getChannel().close();
            // Close scan client
            this.scanClient.close();
        };
        this.setLoggingLevel = (level) => {
            this.logger.setLoggingLevel(level);
        };
        this.configLoggingCallback = (cb) => {
            this.logger.configLoggingCallback(cb);
        };
        const key = typeof credent === 'string' ? credent : credent.secret;
        this.timeout = timeout;
        this.credentKey = 'Authorization';
        this.appNameHeader = 'tm-app-name';
        this.logger = new logger_1.Logger();
        let hostname = amaasHostName;
        // Check if the hostname is a valid FQDN
        if (!amaasHostName.includes('.') && !amaasHostName.includes('localhost')) {
            hostname = amaasHostName.length > 0 ? (0, utils_1.getFQDN)(amaasHostName) : hostname;
        }
        try {
            if (enableTLS === true) {
                let channelCred;
                if (caCert) {
                    // Bring Your Own Certificate case
                    const rootCert = (0, fs_1.readFileSync)(caCert);
                    channelCred = grpc_js_1.credentials.createSsl(rootCert);
                }
                else {
                    // Default SSL credentials case
                    channelCred = grpc_js_1.credentials.createSsl();
                }
                const metaCallback = (_params, callback) => {
                    const meta = new grpc_js_1.Metadata();
                    meta.add(this.credentKey, `ApiKey ${key}`);
                    meta.add(this.appNameHeader, appName);
                    callback(null, meta);
                };
                const callCred = grpc_js_1.credentials.createFromMetadataGenerator(metaCallback);
                const combCred = grpc_js_1.credentials.combineChannelCredentials(channelCred, callCred);
                this.scanClient = new scan_grpc_pb_1.ScanClient(hostname, combCred, { 'grpc.service_config_disable_resolution': 1 });
            }
            else {
                this.scanClient = new scan_grpc_pb_1.ScanClient(hostname, grpc_js_1.credentials.createInsecure(), { 'grpc.service_config_disable_resolution': 1 });
            }
        }
        catch (err) {
            const _err = err;
            throw new Error(`Failed to create scan client. ${_err.message}`);
        }
    }
    /**
     * Process error
     *
     * @param err - Error to process
     */
    processError(err) {
        let message;
        if (err.code !== undefined) {
            if (err.code.toString() === 'EACCES') {
                message = `Failed to open file. ${err.message}`;
            }
            else {
                switch (err.code) {
                    case grpc_js_1.status.NOT_FOUND:
                        message = `The requested resource was not found. ${err.details}`;
                        break;
                    case grpc_js_1.status.PERMISSION_DENIED:
                        message = `You do not have sufficient permissions to access this resource. ${err.details}`;
                        break;
                    case grpc_js_1.status.UNAUTHENTICATED:
                        message = `You are not authenticated. ${err.details}`;
                        break;
                    case grpc_js_1.status.DEADLINE_EXCEEDED:
                        message = `The request deadline was exceeded. ${err.details}`;
                        break;
                    case grpc_js_1.status.UNAVAILABLE:
                        if (['HTTP Status: 429; Exceeds rate limit'].includes(err.details)) {
                            message = `Too many requests. ${err.details}`;
                        }
                        else {
                            message = `Service is not reachable. ${err.details}`;
                        }
                        break;
                    default:
                        message = err.details;
                }
            }
        }
        else {
            message = err.message;
        }
        return new Error(message);
    }
    // Init a scan run
    initScanRun(tags) {
        let scanRun;
        if (tags) {
            (0, utils_1.validateTags)(tags);
            scanRun = new scanRun_1.ScanRun(this.scanClient, this.timeout, this.logger, tags);
        }
        else {
            scanRun = new scanRun_1.ScanRun(this.scanClient, this.timeout, this.logger);
        }
        return scanRun;
    }
    /**
     * Scan file and return result
     *
     * @param name - Filename
     * @param tags - Tags to be added to the scan request
     * @param pml - Flag to enable predictive machine learning detection.
     * @param feedback - Flag to use Trend Micro Smart Protection Network's Smart Feedback.
     * @param verbose - Flag to enable verbose mode in returning scan result.
     * @param digest - Flag to enable calculation of digests for cache search and result lookup.
     */
    async scanFile(name, tags, pml = false, feedback = false, verbose = false, digest = true) {
        let size;
        try {
            size = (0, fs_1.statSync)(name).size;
        }
        catch (err) {
            const _err = err;
            throw new Error(`Failed to open file. ${_err.message}`);
        }
        const scanRun = this.initScanRun(tags);
        return await scanRun
            .scanFile(name, size, pml, feedback, verbose, digest)
            .then(result => result)
            .catch(err => {
            throw this.processError(err);
        });
    }
    /**
     * Scan buffer and return scan result
     *
     * @param fileName - Filename
     * @param buff - Buffer to scan
     * @param tags - Tags to be added to the scan request
     * @param pml - Flag to enable predictive machine learning detection.
     * @param feedback - Flag to use Trend Micro Smart Protection Network's Smart Feedback.
     * @param verbose - Flag to enable verbose mode in returning scan result.
     * @param digest - Flag to enable calculation of digests for cache search and result lookup.
     */
    async scanBuffer(fileName, buff, tags, pml = false, feedback = false, verbose = false, digest = true) {
        const scanRun = this.initScanRun(tags);
        return await scanRun
            .scanBuffer(fileName, buff, pml, feedback, verbose, digest)
            .then(result => result)
            .catch(err => {
            throw this.processError(err);
        });
    }
}
exports.AmaasGrpcClient = AmaasGrpcClient;
